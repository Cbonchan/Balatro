@@startuml diagramaClases
/'incompleto'/

 class Jugador {
     - puntos: int
     - cantidadDescartes: int
     - cantidadJugadas: int
     - mano: Mano
     - mazo: Mazo
     - cartasDescartadas: PilaDescarte
     - List<Carta> cartas
     - List<Activable> jokers
     - List<Activable> tarots
     - List<ActivableEnCarta> tarotsParaCarta
     + Jugador(mano: Mano)
     + seleccionarCarta(cartas: Poker): void
     + cancelarEleccion():void
     + descartarMano():void
     + jugarMano(): void
     + agregarCartas(List<Carta>): int
     + agregarCartasFaltantes(): void
     + agregarJoker(joker:Activable):void
     + eliminarJoker(joker:Activable):void
     + agregarTarot(tarot:Activable):void
     + eliminarTarot(tarot:Activable):void
     + agregarTarotParaCarta(tarot:ActivableEnCarta):void
     + eliminarTarotParaCarta(tarot:ActivableEnCarta):void
     + soyMayorA(puntosASuperar:int):void
     + quedanDescartes():boolean
     + quedanJugadas():boolean
     + actualizarCantidadDeManosYDescartes(manos:int, descartes:int):void
     + reiniciarPuntos():void
 }


 class Carta {
     - palo: Palo
     - figuta: Figura
     - nombre: String
     - puntaje: Puntaje
     - miAnteriorCartaEs(figuraActual: Figura): boolean
     - esMismaFiguraQue(figuraActual: Figura): boolean
     - miPaloEs(paloActual: Palo): boolean
     + Carta(palo: Palo, figura: Figura)
     + obtenerOrden(): int
     + laCartaSiguienteEs(siguienteCartaList: Poker): boolean
     + laCartaSiguienteMismoPalo(siguienteCartaList: Poker): boolean
     + tieneMismaFiguraQue(siguienteCartaList: Poker): boolean
     + esFiguraIgualA(figura: Figura): boolean
     + sumarPuntajeCon(otroPuntaje: Puntaje): void
     + getImage():Image
 }

abstract class Figura{
    - nombre: String
    +Figura (nombre: String)
    + {abstract} orden(): int
    + {abstract} asignarPuntaje(): Puntaje
    + {abstract} esIgualA(): Boolean
    + {abstract} miSiguienteFiguraEs(figura: Figura): Boolean
}

abstract class Palo{
    - nombre: String
    +Palo (nombre: String)
    + {abstract} somosMismoPalo(palo: Palo): boolean
}


 class Mano {
     - jugada: Jugada
     - ArrayList<Carta> cartas
     - ArrayList<Jugada> jugadasPosibles
     - puntajeTotal:Puntaje
     - determinarJugada(List<Carta>): Jugada
     + Mano()
     + reiniciarPuntaje():void
     + obtenerChips(): int
     + aumentarChips(incremento: Chip): void
     + cambiarChipPor(nuevoValor: int): void
     + agregarCarta(cartaCarta: Carta): void
     + sumarMultiplicador(Multiplicador incremento): void
     + multiplicarMultiplicador(multiplicador: Multiplicador): void
     + mejorarJugada(incrementador: int, multiplicador: Multiplicador, jugadaElegida String): void
     + validarNombreMano(manoAValidar: String): boolean
     + aumentarPuntos(puntos: int): void
     + vaciarMano(): void
     + calcularPuntaje(): int
     + cartasAcumuladas(List<Carta>)): List<Carta>
 }

  abstract class Jugada{
      +Jugada(chip: Chip, multiplicador: Multiplicador)
      {abstract} validarNombreJugada(manoAValidar: String): boolean
      {abstract} esJugadaValida(List<Carta>): boolean
      {abstract} cartasJugadas(List<Carta>): List<Carta>
      -ordenarCartas(List<Carta>): List<Carta>
      +mejorar(incrementador: int, multiplicador: Multiplicador): void
      +obtenerMultiplicador(): int
      + calcularPuntaje(puntajeList Puntaje): int
  }

 abstract class Joker implements Activable{
    -nombre: String
    -descripcion: String
    -activacion: String
    -efecto: Efecto
    -incrementador: int
    -multiplicador: Multiplicador
    +Joker(nombre: String, descripcion: String, activacion: String, incrementador: int, multiplicador: Multiplicador,efecto: Efecto)
    {abstract}activar(mano: Mano, contexto: String): void
 }

 abstract class Tarot implements Activable{
    -nombre: String
    -descripcion: String
    -incrementador: int
    -multiplicador: Multiplicador
    -efecto: Efecto
    +Tarot(nombre: String, descripcion: String, incrementador: int, multiplicador: Multiplicador, efecto: Efecto)
    {abstract}activar(mano: Mano, contexto: String): void
 }

 interface Activable{
    {abstract}activar(mano: Mano, contexto: String): void
 }

abstract class Efecto{
{abstract} activar(incrementador: int, multiplicador: Multiplicador, mano: Mano): void
}

class PilaDescarte {
    - manosDescartadas: List<Carta>
    - cantidadManosDescartadas: int
    + PilaDescarte()
    + descartarMano(mano: Mano): void
    + reinsertarEnMazo(Mazo: mazo): void
 }

class Mazo{
    -List<Carta> mazoDeCartas
    +Mazo()
    +getCartasDisponibles(): int
    +cartaAleatoria(): Carta
    +repartirCartas(jugador: Jugador): void
    +reinsertarCartas(List<Carta>): void
}

class Ronda{
    -numero: int
    -manos: int
    -descartes: int
    -puntajeASuperar: int
    -tienda: Tienda
    +Ronda(numero: int, manos: int, descartes: int, puntajeASuperar: int, tienda: Tienda)
    +comenzar(jugador: Jugador): void
}

class Juego{
    -jugador: Jugador
    -nroRonda: int
    -rondas: List<Ronda>
    -rondaActual: Ronda
    +Juego()
    +avanzarRonda():void
}

class Tienda{
    -List<Activable> activables
    -carta: Carta
    +Tienda(List<Activable> activables, carta: Carta)
    +venderCarta():void
}

Juego *--"8 " Ronda
Ronda *-- Tienda
PilaDescarte --* Jugador
Jugador *-- Mano
Mano -->"0..5   " Carta
Mano *-.-"10 " Jugada
Jugador --->"0..8  " Carta
PilaDescarte ..> Mano
Mazo <.. PilaDescarte
Mazo ...> Jugador
Mazo -->" 0..*    " Carta
Carta --> Palo
Carta --> Figura
Mazo --* Jugador
Jugador -->"0..5" Joker
Jugador -->"0..2 " Tarot
Efecto <|. Tarot
Efecto <|. Joker
Tienda--> Activable
Carta <- Tienda
Juego --> Jugador
PilaDescarte -->"0..* " Carta
Jugador <... Ronda
 @enduml